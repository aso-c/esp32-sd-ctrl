/*
 * SD-card input/output classes
 * Include file
 * 	@file   sdcard_io
 *	@author	Solomatov A.A. (aso)
 *	@date	Created 20.09.2022
 *		Updated 29.04.2025
 *	@version 0.9.6.1
 *
 */


//using namespace idf;


#pragma once

#ifndef __cplusplus
#error "The sdcard_ctrl file usable in C++ projects only."
#endif


#include <utility>


namespace FAT
{
    namespace mount
    {
	struct config: esp_vfs_fat_sdmmc_mount_config_t
	{
	    constexpr config& operator = (const esp_vfs_fat_sdmmc_mount_config_t& src)
	    {
		format_if_mount_failed = src.format_if_mount_failed;
		max_files  = src.max_files;
		allocation_unit_size     = src.allocation_unit_size;
		disk_status_check_enable = src.disk_status_check_enable;
		use_one_fat = src.use_one_fat;
		return *this;
	    }; /* FAT::mount::config::operator = () */

	}; /* FAT::mount::config */
//	constexpr esp_vfs_fat_sdmmc_mount_config_t def = VFS_FAT_MOUNT_DEFAULT_CONFIG();
	constexpr config def = {/*esp_vfs_fat_sdmmc_mount_config_t(*/VFS_FAT_MOUNT_DEFAULT_CONFIG()/*)*/};
#if 0
typedef struct {
    /**
     * If FAT partition can not be mounted, and this parameter is true,
     * create partition table and format the filesystem.
     */
    bool format_if_mount_failed;
    int max_files;                  ///< Max number of open files
    /**
     * If format_if_mount_failed is set, and mount fails, format the card
     * with given allocation unit size. Must be a power of 2, between sector
     * size and 128 * sector size.
     * For SD cards, sector size is always 512 bytes. For wear_levelling,
     * sector size is determined by CONFIG_WL_SECTOR_SIZE option.
     *
     * Using larger allocation unit size will result in higher read/write
     * performance and higher overhead when storing small files.
     *
     * Setting this field to 0 will result in allocation unit set to the
     * sector size.
     */
    size_t allocation_unit_size;
    /**
     * Enables real ff_disk_status function implementation for SD cards
     * (ff_sdmmc_status). Possibly slows down IO performance.
     *
     * Try to enable if you need to handle situations when SD cards
     * are not unmounted properly before physical removal
     * or you are experiencing issues with SD cards.
     *
     * Doesn't do anything for other memory storage media.
     */
    bool disk_status_check_enable;
    /**
     * Use 1 FAT (File Allocation Tables) instead of 2.
     * This decreases reliability, but makes more space available
     * (usually only one sector).
     * Note that this option has effect only when the filesystem is formatted.
     * When mounting an already-formatted partition, the actual number of FATs
     * may be different.
     */
    bool use_one_fat;
} esp_vfs_fat_mount_config_t;

#define VFS_FAT_MOUNT_DEFAULT_CONFIG() \
    { \
	.format_if_mount_failed = false, \
	.max_files = 5, \
	.allocation_unit_size = 0, \
	.disk_status_check_enable = false, \
	.use_one_fat = false, \
    }
#endif
    }; /* FAT::mount */
}; /* FAT */

namespace SD //--------------------------------------------------------------------------------------------------------
{

    class Card;

    /// General definition of the SD MMC/SPI/other card hosts
    struct Host
    {
	friend class Card;

	enum class flags: uint32_t {
	    _1bit = SDMMC_HOST_FLAG_1BIT,	/*!< host supports 1-line SD and MMC protocol */
	    _4bit = SDMMC_HOST_FLAG_4BIT,	/*!< host supports 4-line SD and MMC protocol */
	    _8bit = SDMMC_HOST_FLAG_8BIT,	/*!< host supports 8-line MMC protocol */
	    spi   = SDMMC_HOST_FLAG_SPI,	/*!< host supports SPI protocol */
	    ddr   = SDMMC_HOST_FLAG_DDR,	/*!< host supports DDR mode for SD/MMC */
	    deinit  = SDMMC_HOST_FLAG_DEINIT_ARG,	/*!< host `deinit` function called with the slot argument */
	    int_buf = SDMMC_HOST_FLAG_ALLOC_ALIGNED_BUF      /*!< Allocate internal buffer of 512 bytes that meets DMA's requirements.
                                                 Currently this is only used by the SDIO driver. Set this flag when
                                                 using SDIO CMD53 byte mode, with user buffer that is behind the cache
                                                 or not aligned to 4 byte boundary. */
	}; /* enum class SD::Host::flags */


	enum class freq: int {
	    def     = SDMMC_FREQ_DEFAULT,	/*!< SD/MMC Default speed (limited by clock divider) */
	    high    = SDMMC_FREQ_HIGHSPEED,	/*!< SD High speed (limited by clock divider) */
	    probing = SDMMC_FREQ_PROBING,	/*!< SD/MMC probing speed */
	    _52M    = SDMMC_FREQ_52M,	/*!< MMC 52MHz speed */
	    _26M    = SDMMC_FREQ_26M,	/*!< MMC 26MHz speed */
	    ddr50   = SDMMC_FREQ_DDR50,	/*!< MMC 50MHz speed */
	    sdr50   = SDMMC_FREQ_SDR50,	/*!< MMC 100MHz speed */
	}; /* SD::Host::Freq */

	//TODO Must implemented inner class "Mounter" with one pure virtual method operator() that emulated operation 'mount()'
	//TODO intendet, that class store hided reference to configuration parameters for 'mount' procedure, specifical for MMC or SPI hosts

//	// "copy" constructor
//	Host(const sdmmc_host_t& xcfg /*= sdmmc_host_t(SDMMC_HOST_DEFAULT())*/, MMC::slot num = MMC::slot::number_0): cfg(xcfg) {};
//	// copy constructor
//	Host(const Host& host): Host(host.cfg) {};
//
	//! @brief holder additional information for mounting procedure
	class mounter;

	Host(mounter& amounter): mount(amounter) {};
	virtual ~Host() = default;

	/// Last operation return status / error status
	esp_err_t state() { return err;};

	/// Clear the error status
	void reset_state() { err = ESP_OK;};


	//!
	// @brief Initialize given slot of SDMMC peripheral
	//
	// On the ESP32, SDMMC peripheral has two slots:
	//  - Slot 0: 8-bit wide, maps to HS1_* signals in PIN MUX
	//  - Slot 1: 4-bit wide, maps to HS2_* signals in PIN MUX
	//
	// Card detect and write protect signals can be routed to
	// arbitrary GPIOs using GPIO matrix.
	//
	// @note This function is not thread safe
	//
	// @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	// @param slot_config  additional configuration for the slot
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_INVALID_STATE if host has not been initialized using sdmmc_host_init
#if 0
// TODO fo remove
	esp_err_t virtual init(const MMC::Slot& extslot) = 0;
#endif
	esp_err_t virtual init() = 0;

	//!
	// @brief Set card clock frequency
	//
	// Currently only integer fractions of 40MHz clock can be used.
	// For High Speed cards, 40MHz can be used.
	// For Default Speed cards, 20MHz can be used.
	//
	// @note This function is not thread safe
	//
	// @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	// @param freq_khz  card clock frequency, in kHz
	// @return
	//      - ESP_OK on success
	//      - other error codes may be returned in the future
	esp_err_t virtual card_clk(uint32_t freq_khz) = 0;
	//TODO To remove
	//esp_err_t virtual set_card_clk(uint32_t freq_khz) = 0;


	//!
	// @brief Send command to the card and get response
	//
	// Host function to do a transaction
	// This function returns when command is sent and response is received,
	// or data is transferred, or timeout occurs.
	//
	// @note This function is not thread safe w.r.t. init/deinit functions,
	//       and bus width/clock speed configuration functions. Multiple tasks
	//       can call sdmmc_host_do_transaction as long as other sdmmc_host_*
	//       functions are not called.
	//
	// @attention Data buffer passed in cmdinfo->data must be in DMA capable memory
	//
	// @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	// @param cmdinfo   pointer to structure describing command and data to transfer
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_TIMEOUT if response or data transfer has timed out
	//      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed
	//      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response
	//      - ESP_ERR_INVALID_SIZE if the size of data transfer is not valid in SD protocol
	//      - ESP_ERR_INVALID_ARG if the data buffer is not in DMA capable memory
	esp_err_t virtual transaction(sdmmc_command_t *cmdinfo) = 0;
	esp_err_t virtual transaction(sdmmc_command_t& cmdinfo) = 0;

	//!
	// @brief Convenience function to get FAT filesystem on SD card registered in VFS
	//
	// This is an all-in-one function which does the following:
	// - initializes SDMMC driver or SPI driver with configuration in host_config
	// - initializes SD card with configuration in slot_config
	// - mounts FAT partition on SD card using FATFS library, with configuration in mount_config
	// - registers FATFS library with VFS, with prefix given by base_prefix variable
	//
	// This function is intended to make example code more compact.
	// For real world applications, developers should implement the logic of
	// probing SD card, locating and mounting partition, and registering FATFS in VFS,
	// with proper error checking and handling of exceptional conditions.
	//
	// @note Use this API to mount a card through SDSPI is deprecated. Please call
	//       `esp_vfs_fat_sdspi_mount()` instead for that case.
	//
	// @param base_path     path where partition should be registered (e.g. "/sdcard")
	// @param host_config   Pointer to structure describing SDMMC host. When using
	//                      SDMMC peripheral, this structure can be initialized using
	//                      SDMMC_HOST_DEFAULT() macro. When using SPI peripheral,
	//                      this structure can be initialized using SDSPI_HOST_DEFAULT()
	//                      macro.
	// @param slot_config   Pointer to structure with slot configuration.
	//                      For SDMMC peripheral, pass a pointer to sdmmc_slot_config_t
	//                      structure initialized using SDMMC_SLOT_CONFIG_DEFAULT.
	// @param mount_config  pointer to structure with extra parameters for mounting FATFS
	// @param[out] out_card  if not NULL, pointer to the card information structure will be returned via this argument
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called
	//      - ESP_ERR_NO_MEM if memory can not be allocated
	//      - ESP_FAIL if partition can not be mounted
	//      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers
	class mounter
	{
	public:
	    esp_err_t virtual operator()(std::string_view path, /*esp_vfs_fat_mount_config_t&*/ FAT::mount::config& mount_config, Card& card) = 0;
	    virtual ~mounter() = default;
	}; /* class SD::Host::mounter */

	//! @brief The mounter class object, emulate 'mount()' procedure
	mounter &mount;
	//TODO 4remove
//	esp_err_t virtual mount(std::string_view path, esp_vfs_fat_mount_config_t& mount_config, Card& card) = 0;

	//!
	// @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_sdmmc_mount
	//
	// @deprecated Use `esp_vfs_fat_sdcard_unmount()` instead.
	//
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called
	//TODO For remove
//	[[deprecated("Use \"esp_vfs_fat_sdcard_unmount()\" instead")]]
//	 esp_err_t unmount() { return (err = esp_vfs_fat_sdmmc_unmount()); };

	//!
	// @brief Unmount an SD card from the FAT filesystem and release resources acquired using
	//        `esp_vfs_fat_sdmmc_mount()` or `esp_vfs_fat_sdspi_mount()`
	//
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_INVALID_ARG if the card argument is unregistered
	//      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called
	esp_err_t unmount(std::string_view path, Card& card);


	//!
	// @brief Disable SDMMC host and release allocated resources
	//
	// @note This function is not thread safe
	//
	// @return
	//      - ESP_OK on success
	//      - ESP_ERR_INVALID_STATE if sdmmc_host_init function has not been called
	esp_err_t virtual deinit() = 0;

	struct IO
	{
	    struct INT
	    {
		//!
		// @brief Enable IO interrupts
		//
		// This function configures the host to accept SDIO interrupts.
		// (Public wrapper which call private virtual implementation of it.)
		//
		// @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
		// @return returns ESP_OK, other errors possible in the future
		esp_err_t enable() { return io.host.io_int_enable(); };

		//!
		// @brief Block until an SDIO interrupt is received, or timeout occurs
		//       (Public wrapper which call private virtual implementation of it.)
		// @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
		// @param timeout_ticks  number of RTOS ticks to wait for the interrupt
		// @return
		//  - ESP_OK on success (interrupt received)
		//  - ESP_ERR_TIMEOUT if the interrupt did not occur within timeout_ticks
		esp_err_t wait(TickType_t timeout_ticks) { return io.host.io_int_wait(timeout_ticks);};

	    protected:
		friend class IO;
		INT(IO* parent): io(*parent) {};
	    private:
		IO& io;
	    }; /* SD::Host::IO::INT */

	    INT interrupt;

	protected:
	    friend class Host;
	    IO(Host* parent): interrupt(this), host(*parent) {};
	private:
	    Host& host;

	}; /* struct SD::Host::IO */

	IO io = this;

    protected:

//	// Use settings defined above to initialize SD card and mount FAT filesystem.
//	// Note: esp_vfs_fat_sdmmc/sdspi_mount is all-in-one convenience functions.
//	// Please check its source code and implement error recovery when developing
//	// production applications.
//	sdmmc_host_t cfg;

	/// Error status of the last operation.
	esp_err_t err = ESP_OK;

	//!
	// @brief Enable IO interrupts
	//
	// This function configures the host to accept SDIO interrupts.
	// (Private pure virtual method whuch implementation of it.)
	//
	// @param slot  -- param is not used, instead used inner value of the cfg.slot -- slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	// @return returns ESP_OK, other errors possible in the future
	esp_err_t virtual io_int_enable() = 0;

	//!
	// @brief Block until an SDIO interrupt is received, or timeout occurs
	//       (Public wrapper which call private virtual implementation of it.)
	// @param slot    -- param is not used, instead used inner value of the cfg.slot -- slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	// @param timeout_ticks  number of RTOS ticks to wait for the interrupt
	// @return
	//  - ESP_OK on success (interrupt received)
	//  - ESP_ERR_TIMEOUT if the interrupt did not occur within timeout_ticks
	esp_err_t virtual io_int_wait(TickType_t timeout_ticks) = 0;

    }; /* struct SD::Host */


    /// MMC abstraction namespace
    namespace MMC
    {

	namespace slot
	{
	    /// slot number designation
	    enum no: int8_t
	    {
		number_0 = SDMMC_HOST_SLOT_0,
		number_1 = SDMMC_HOST_SLOT_1,
		one=number_1,
		null=number_0,
		def = one,
		out_of_range = -1
	    }; /* enum class SD::MMC::slot */

	    /// slot flags
	    enum flag: uint8_t
	    {
		none,
		//default = none,
		pullup	= SDMMC_SLOT_FLAG_INTERNAL_PULLUP,
		wp_high	= SDMMC_SLOT_FLAG_WP_ACTIVE_HIGH,
		uhs1	= SDMMC_SLOT_FLAG_UHS1,
	    }; /* enum SD::MMC::slot::flag */

	    constexpr uint32_t flag2uint32(flag flg) { return static_cast<uint32_t>(flg); };
	}; /* namespace SD::MMC::slot */

	constexpr uint32_t operator | (uint32_t uleft, slot::flag right) {
		return (uleft | static_cast<uint32_t>(right));
	}
	constexpr uint32_t operator | (slot::flag left, uint32_t uright) {
		return (uright | left);
	}
	uint32_t operator | (slot::flag left, slot::flag right) {
		return static_cast<uint32_t>(left) | right;
	}

	constexpr uint32_t& operator |=(uint32_t& acc, slot::flag flg) { return acc |= static_cast<uint32_t>(flg); };
	constexpr uint32_t  operator ~(slot::flag flg) { return ~static_cast<uint32_t>(flg); };


#if 0
	/// pullup-state designation
	enum class pullup: uint8_t {
	    no,
	    yes = slot::pullup
	}; /* enum class SD::MMC::Host::pullup*/

	/// write-protect bit encoding
	namespace wp
	{
	    enum class active: int8_t
	    {
		low,
		high = slot::wp_high
	    }; /* enum class SD::MMC::wp::active */
	}; /* namespace SD::MMC::wp */

	/// write speed mode - UHS-1 or not
	enum class uhs: uint8_t {
	    no,
	    mode1 = slot::uhs1
	}; /* enum class SD::MMC::Host::pullup*/
#endif

	namespace bus
	{
	    /// bus width designation
	    enum class width: uint8_t
	    {
		def = SDMMC_SLOT_WIDTH_DEFAULT, /* maximum bus width of the slot*/
		_1 = 1,
		one = _1,
		_4 = 4,
		four = _4,
		_8 = 8,
		eight = _8
	    }; /* enum class SD::MMC::bus::width */
	}; /* namespace SD::MMC::bus */


	/// @brief SD::MMC::Slot class for emcapsulating struct sdmmc_slot_config_t
	struct Slot
	{

	    constexpr Slot() {};	///< Default config - Slot configured to Slot_1
	    constexpr Slot(uint32_t sflags, bus::width swidth = bus::width::def) {
		flags(sflags);
		width(swidth);
	    };
//	    Slot(MMC::pullup pullup_st = pullup::no, wp::active level = wp::active::low, uhs mode = uhs::no);
	    /// @brief copy constructor
	    /// @param slot ource of the slot configuration
	    constexpr Slot(const Slot& slot): cfg(slot.cfg) {};
	    /// @brief copy constructor from sdmmc_slot_config_t param
	    /// @param slcfg  ource of the slot configuration of the type sdmmc_slot_config_t
	    constexpr Slot(const sdmmc_slot_config_t& slcfg): cfg(slcfg) {};
	    /// @brief Full direct generation of the Slot object
	    /// @param clk  GPIO number of CLK signal.
	    /// @param cmd  GPIO number of CMD signal.
	    /// @param d0  GPIO number of D0 signal.
	    /// @param d1  GPIO number of D1 signal.
	    /// @param d2  GPIO number of D2 signal.
	    /// @param d3  GPIO number of D3 signal.
	    /// @param d4  GPIO number of D4 signal. Ignored in 1- or 4- line mode.
	    /// @param d5  GPIO number of D5 signal. Ignored in 1- or 4- line mode.
	    /// @param d6  GPIO number of D6 signal. Ignored in 1- or 4- line mode.
	    /// @param d7  GPIO number of D7 signal. Ignored in 1- or 4- line mode.
	    /// @param cd  GPIO number of card detect signal; shorter name.
	    /// @param wp  GPIO number of write protect signal; shorter name.
	    /// @param width  Bus width used by the slot (might be less than the max width supported)
	    /// @param flags  Features used by this slot
	    constexpr Slot(gpio_num_t clk, gpio_num_t cmd, gpio_num_t d0, gpio_num_t d1, gpio_num_t d2,
			    gpio_num_t d3, gpio_num_t d4, gpio_num_t d5, gpio_num_t d6, gpio_num_t d7,
			    gpio_num_t cd, gpio_num_t wp, uint8_t width, uint32_t flags):
			    cfg {.clk = clk,      
				 .cmd = cmd,      
				 .d0  = d0,       
				 .d1  = d1,       
				 .d2  = d2,       
				 .d3  = d3,       
				 .d4  = d4,       
				 .d5  = d5,       
				 .d6  = d6,       
				 .d7  = d7,       
				 .cd  = cd,       
				 .wp  = wp,       
				 .width = width,  
				 .flags = flags, }
			     {};

	    // This initializes the slot without card detect (CD) and write protect (WP) signals.
	    // Modify slot_config.gpio_cd and slot_config.gpio_wp if your board has these signals.
	    sdmmc_slot_config_t cfg = SDMMC_SLOT_CONFIG_DEFAULT();

	    /// @brief Set the new flags value
	    /// @param newflags a new flags value, implied using enum SD::MMC::slot::flags
	    constexpr void flags(uint32_t newflags) {
		cfg.flags = newflags;
	    };

	    constexpr uint32_t flags() {
		return cfg.flags;
	    };

	    constexpr uint32_t set_flags(slot::flag sflag) {
		return cfg.flags |= sflag;
	    }

	    constexpr uint32_t clear_flags(slot::flag sflag) {
		return cfg.flags &= ~sflag;
	    }
	
	    
	    //!
	    // @brief   set the width the bus of the desired host
	    // @param   width: desired host bus width
	    // @return  none
	    void constexpr width(bus::width width)  {
		cfg.width = static_cast<uint8_t>(width);
	    }; /* SD::MMC::Slot::pullup() */
	    //!
	    // @brief   return width of the bus for the desired host
	    // @param   none
	    // @return  desired host bus width
	    uint8_t constexpr width() {return cfg.width;};


	    Slot& operator =(const Slot&);
	    Slot& operator =(const sdmmc_slot_config_t&);
	    Slot& operator =(sdmmc_slot_config_t&&) noexcept;

	    operator sdmmc_slot_config_t&() {return cfg;};
	    operator sdmmc_slot_config_t*() {return &cfg;};

	}; /* struct SD::MMC::Slot */



	//=================================================
	// SD::MMC::Host
	struct Host: public SD::Host
	{
	    friend class SD::Card;


	    //! Default constructor
	    constexpr Host(Slot& extslot): SD::Host(inner), inner(extslot) {};

	    constexpr Host(slot::no no, Slot& extslot, uint32_t setflags = 0, int maxfreq = SDMMC_FREQ_DEFAULT):
	    SD::Host(inner),
	    inner(extslot)
	    { };
	    //Host(slot::no no, uint32_t setflags, int maxfreq);

	    //! "copy" constructor
	    constexpr Host(Slot& extslot, const sdmmc_host_t& xhost):SD::Host(inner), instance(xhost), inner(extslot) {};
	    //! copy constructor
	    constexpr Host(const Host& xhost):SD::Host(inner), instance(xhost.instance), inner(xhost.inner) {};

#if 0
	    Host(bus::width = bus::width::def, pullup = pullup::no);
	    // Constructor with default slot configuration by number of the slot
	    Host(SD::MMC::Slot, bus::width = bus::width::def, pullup = pullup::no);
	    // Custom slot configuration in temporary obj for desired slot number
	    Host(SD::MMC::Slot, const Slot&, bus::width = bus::width::def, pullup = pullup::no);	// in lvalue object
	    // Copy constructors
	    Host(const Host&, bus::width = bus::width::def, pullup = pullup::no);		// for lvalue object (defined variable)
	    // for lvalue object (defined variable)
	    Host(const sdmmc_host_t&, bus::width = bus::width::def, pullup = pullup::no);
	    // for lvalue object (defined variable)
	    Host(const sdmmc_host_t& ehost, const sdmmc_slot_config_t& eslot, bus::width busw = bus::width::def, pullup pullst = pullup::no):
		Host(ehost, busw, pullst) {
		ESP_LOGD("sdcard_io header", "constructor SD::MMC::Host::Host(const sdmmc_host_t& ehost, const sdmmc_slot_config_t& eslot, bus::width busw = bus::width::def, pullup pullst = pullup::no)");
		slot = eslot;
	    };
#endif
	    ~Host() override = default;

	    // Use settings defined above to initialize SD card and mount FAT filesystem.
	    // Note: esp_vfs_fat_sdmmc/sdspi_mount is all-in-one convenience functions.
	    // Please check its source code and implement error recovery when developing
	    // production applications.

	    //Slot slot;

//	    Slot& slot() { return _slot;};

	    operator sdmmc_host_t&();
	    operator sdmmc_host_t*();

	    Host& operator =(const Host&);
	    Host& operator =(const sdmmc_host_t&);

	//    void constexpr pullup(pullup pullup_st) { slot.pullup(pullup_st);}
	//    bool constexpr pullup() {return slot.pullup();};

	    /// @warning use сarefully! may be incorrect behavior!
	    int constexpr slot_no() { return instance.slot; };
	    void constexpr slot_no(SD::MMC::slot::no num) {
		instance.slot = static_cast<int>(num);
	    }; /* SD::MMC::Host::slot_no(Slot::number) */
	;


	    // Use settings defined above to initialize SD card and mount FAT filesystem.
	    // Note: esp_vfs_fat_sdmmc/sdspi_mount is all-in-one convenience functions.
	    // Please check its source code and implement error recovery when developing
	    // production applications.
	    sdmmc_host_t instance = SDMMC_HOST_DEFAULT();
	    /*instance.max_freq_khz = SDMMC_FREQ_HIGHSPEED;*/

	    //!
	    // @brief Convenience function to get FAT filesystem on SD card registered in VFS
	    //
	    // This is an all-in-one function which does the following:
	    // - initializes SDMMC driver or SPI driver with configuration in host_config
	    // - initializes SD card with configuration in slot_config
	    // - mounts FAT partition on SD card using FATFS library, with configuration in mount_config
	    // - registers FATFS library with VFS, with prefix given by base_prefix variable
	    //
	    // This function is intended to make example code more compact.
	    // For real world applications, developers should implement the logic of
	    // probing SD card, locating and mounting partition, and registering FATFS in VFS,
	    // with proper error checking and handling of exceptional conditions.
	    //
	    // @note Use this API to mount a card through SDSPI is deprecated. Please call
	    //       `esp_vfs_fat_sdspi_mount()` instead for that case.
	    //
	    // @param base_path     path where partition should be registered (e.g. "/sdcard")
	    // @param host_config   Pointer to structure describing SDMMC host. When using
	    //                      SDMMC peripheral, this structure can be initialized using
	    //                      SDMMC_HOST_DEFAULT() macro. When using SPI peripheral,
	    //                      this structure can be initialized using SDSPI_HOST_DEFAULT()
	    //                      macro.
	    // @param slot_config   Pointer to structure with slot configuration.
	    //                      For SDMMC peripheral, pass a pointer to sdmmc_slot_config_t
	    //                      structure initialized using SDMMC_SLOT_CONFIG_DEFAULT.
	    // @param mount_config  pointer to structure with extra parameters for mounting FATFS
	    // @param[out] out_card  if not NULL, pointer to the card information structure will be returned via this argument
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called
	    //      - ESP_ERR_NO_MEM if memory can not be allocated
	    //      - ESP_FAIL if partition can not be mounted
	    //      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers
	    //
	    class mounter: public SD::Host::mounter
	    {
	    public:
		constexpr mounter(Slot& eslot): slot(eslot) {};
		constexpr mounter(const mounter& mntr): slot(mntr.slot) {};
		esp_err_t operator()(std::string_view path, /*esp_vfs_fat_mount_config_t&*/ FAT::mount::config& mount_config, Card& card) override;
	    private:
		Slot& slot;
		friend class Host;
//		friend esp_err_t Host::init();
	    }; /* class SD::MMC::Host::mounter */

//	    esp_err_t mount(std::string_view path, esp_vfs_fat_mount_config_t& mount_config, Card& card) override;

	    //!
	    // @brief Initialize given slot of SDMMC peripheral
	    //
	    // On the ESP32, SDMMC peripheral has two slots:
	    //  - Slot 0: 8-bit wide, maps to HS1_* signals in PIN MUX
	    //  - Slot 1: 4-bit wide, maps to HS2_* signals in PIN MUX
	    //
	    // Card detect and write protect signals can be routed to
	    // arbitrary GPIOs using GPIO matrix.
	    //
	    // @note This function is not thread safe
	    //
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param slot_config  additional configuration for the slot
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_STATE if host has not been initialized using sdmmc_host_init
#if 0
	    // TODO to remove
	    esp_err_t init(const Slot& extslot) override {return (err = sdmmc_host_init_slot(instance.slot, &const_cast<Slot&>(extslot).cfg)); };
#endif
	    esp_err_t init() override {return (err = sdmmc_host_init_slot(instance.slot, &inner.slot.cfg)); };
//	    esp_err_t init(MMC::slot::no, const Slot& extern_slot);
//	    esp_err_t init(MMC::slot::no, Slot&& extern_slot);

	    //!
	    // @brief Select bus width to be used for data transfer
	    //
	    // SD/MMC card must be initialized prior to this command, and a command to set
	    // bus width has to be sent to the card (e.g. SD_APP_SET_BUS_WIDTH)
	    //
	    // @note This function is not thread safe
	    //
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param width  bus width: 1, 4, or 8 for slot 0; 1 or 4 for slot 1
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_ARG if slot number or width is not valid
	    esp_err_t bus_width(bus::width width) {

		return (err = instance.set_bus_width/*sdmmc_host_set_bus_width*/(instance.slot, static_cast<uint8_t/*size_t*/>(width))); };

	    //!
	    // @brief Get bus width configured in ``sdmmc_host_init_slot`` to be used for data transfer
	    //
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @return configured bus width of the specified slot.
	    size_t bus_width() { return instance.get_bus_width(instance.slot); };

	    //!
	    // @brief Set card clock frequency
	    //
	    // Currently only integer fractions of 40MHz clock can be used.
	    // For High Speed cards, 40MHz can be used.
	    // For Default Speed cards, 20MHz can be used.
	    //
	    // @note This function is not thread safe
	    //
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param freq_khz  card clock frequency, in kHz
	    // @return
	    //      - ESP_OK on success
	    //      - other error codes may be returned in the future
	    //        esp_err_t (*set_card_clk)(int slot, uint32_t freq_khz); /*!< host function to set card clock frequency */
	    esp_err_t card_clk(uint32_t freq_khz) override {return (err = instance.set_card_clk(instance.slot, freq_khz)); };

	    //!
	    // @brief Enable or disable DDR mode of SD interface
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param ddr_enabled  enable or disable DDR mode
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_NOT_SUPPORTED if DDR mode is not supported on this slot
	    esp_err_t set_ddr_mode(bool ddr_enabled) { return (err = instance.set_bus_ddr_mode(instance.slot, ddr_enabled)); };

	    //!
	    // @brief Send command to the card and get response
	    //
	    // Host function to do a transaction
	    // This function returns when command is sent and response is received,
	    // or data is transferred, or timeout occurs.
	    //
	    // @note This function is not thread safe w.r.t. init/deinit functions,
	    //       and bus width/clock speed configuration functions. Multiple tasks
	    //       can call sdmmc_host_do_transaction as long as other sdmmc_host_*
	    //       functions are not called.
	    //
	    // @attention Data buffer passed in cmdinfo->data must be in DMA capable memory
	    //
	    // @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param cmdinfo   pointer to structure describing command and data to transfer
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_TIMEOUT if response or data transfer has timed out
	    //      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed
	    //      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response
	    //      - ESP_ERR_INVALID_SIZE if the size of data transfer is not valid in SD protocol
	    //      - ESP_ERR_INVALID_ARG if the data buffer is not in DMA capable memory
	    esp_err_t transaction(sdmmc_command_t *cmdinfo) override { return (err = instance.do_transaction(instance.slot, cmdinfo)); };
	    esp_err_t transaction(sdmmc_command_t& cmdinfo) override { return (err = instance.do_transaction(instance.slot, &cmdinfo)); };

	    //!
	    // @brief Disable SDMMC host and release allocated resources
	    //
	    // @note This function is not thread safe
	    //
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_STATE if sdmmc_host_init function has not been called
	    esp_err_t constexpr deinit(void) override { return (err = sdmmc_host_deinit());};

	private:

		/// @brief inner implementation of the mounter for a SD::MMC::Host
		mounter inner;

	    //!
	    // @brief Enable IO interrupts
	    //
	    // This function configures the host to accept SDIO interrupts.
	    // (Private pure virtual method whuch implementation of it.)
	    //
	    // @param slot  -- param is not used, instead used inner value of the cfg.slot -- slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @return returns ESP_OK, other errors possible in the future
	    esp_err_t constexpr io_int_enable() override { return (err = instance.io_int_enable(instance.slot));};

	    //!
	    // @brief Block until an SDIO interrupt is received, or timeout occurs
	    //       (Public wrapper which call private virtual implementation of it.)
	    // @param slot    -- param is not used, instead used inner value of the cfg.slot -- slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)
	    // @param timeout_ticks  number of RTOS ticks to wait for the interrupt
	    // @return
	    //  - ESP_OK on success (interrupt received)
	    //  - ESP_ERR_TIMEOUT if the interrupt did not occur within timeout_ticks
	    //        esp_err_t (*io_int_wait)(int slot, TickType_t timeout_ticks); /*!< Host function to wait for SDIO interrupt line to be active */
	    esp_err_t constexpr io_int_wait(TickType_t timeout_ticks) override { return (err = instance.io_int_wait(instance.slot, timeout_ticks));};

	}; /* struct SD::MMC::Host */

    }; //--[ namespace SD::MMC ]---------------------------------------------------------------------------------------



    // I/O operations for the SD/MMC card
    class IO
    {
    public:

	// Constructor
	IO(Card* holder);

	class Interrupt
	{

	public:
	    Interrupt(IO* io): iohandler(*io) {};

	    //!
	    // Enable SDIO interrupt in the SDMMC host
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_NOT_SUPPORTED if the host controller does not support
	    //        IO interrupts
	    esp_err_t enable();

	    //!
	    // Block until an SDIO interrupt is received
	    //
	    // Slave uses D1 line to signal interrupt condition to the host.
	    // This function can be used to wait for the interrupt.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param timeout_ticks  time to wait for the interrupt, in RTOS ticks
	    // @return
	    //      - ESP_OK if the interrupt is received
	    //      - ESP_ERR_NOT_SUPPORTED if the host controller does not support
	    //        IO interrupts
	    //      - ESP_ERR_TIMEOUT if the interrupt does not happen in timeout_ticks
	    esp_err_t wait(TickType_t ticks);

	private:
	    IO& iohandler;

	}; /* class SD::IO::Interrupt */

	class CIS
	{
	public:
	    CIS(IO* io): iohandler(*io) {};

	    //!
	    // Get the data of CIS region of an SDIO card.
	    //
	    // You may provide a buffer not sufficient to store all the CIS data. In this
	    // case, this function stores as much data into your buffer as possible. Also,
	    // this function will try to get and return the size required for you.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param outbuf out_buffer Output buffer of the CIS data
	    // @param inout_cis_size Mandatory, pointer to a size, input and output.
	    //              - input: Limitation of maximum searching range, should be 0 or larger than
	    //                      buffer_size. The function searches for CIS_CODE_END until this range. Set to
	    //                      0 to search infinitely.
	    //              - output: The size required to store all the CIS data, if CIS_CODE_END is found.
	    //
	    // @return
	    //      - ESP_OK: on success
	    //      - ESP_ERR_INVALID_RESPONSE: if the card does not (correctly) support CIS.
	    //      - ESP_ERR_INVALID_SIZE: CIS_CODE_END found, but buffer_size is less than
	    //              required size, which is stored in the inout_cis_size then.
	    //      - ESP_ERR_NOT_FOUND: if the CIS_CODE_END not found. Increase input value of
	    //              inout_cis_size or set it to 0, if you still want to search for the end;
	    //              output value of inout_cis_size is invalid in this case.
	    //      - and other error code return from sdmmc_io_read_bytes
	    esp_err_t data(std::vector<uint8_t> &outbuf, size_t &inout_cis_size);

	    //!
	    // Parse and print the CIS information of an SDIO card.
	    //
	    // @note Not all the CIS codes and all kinds of tuples are supported. If you
	    // see some unresolved code, you can add the parsing of these code in
	    // sdmmc_io.c and contribute to the IDF through the Github repository.
	    //
	    //              using sdmmc_card_init
	    // @param buff buffer Buffer to parse
	    // @param fp File pointer to print to, set to NULL to print to stdout.
	    //
	    // @return
	    //      - ESP_OK: on success
	    //      - ESP_ERR_NOT_SUPPORTED: if the value from the card is not supported to be parsed.
	    //      - ESP_ERR_INVALID_SIZE: if the CIS size fields are not correct.
	    esp_err_t info(std::vector<uint8_t> buff, FILE *fp);

	private:
	    IO& iohandler;

	}; /* class SD::IO::CIS */


	// I/O Read operation functions
	class Read
	{
	public:
	    Read(IO* io);	// Constructor

	    //!
	    // Read one byte from an SDIO card using IO_RW_DIRECT (CMD52)
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param reg  byte address within IO function
	    // @param[out] out_byte  output, receives the value read from the card
	    // @return
	    //      - ESP_OK on success
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t byte(uint32_t function, uint32_t reg, uint8_t &out_byte);

	    //!
	    // Read multiple bytes from an SDIO card using IO_RW_EXTENDED (CMD53)
	    //
	    // This function performs read operation using CMD53 in byte mode.
	    // For block mode, see sdmmc_io_read_blocks.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param addr  byte address within IO function where reading starts
	    // @param dst  buffer which receives the data read from card
	    // @param size  number of bytes to read; if size is zero - used dst.size()
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes or greater then dst.size()
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t bytes(uint32_t function, uint32_t addr, std::vector<uint8_t> &dst, size_t size = 0);

	    //!
	    // Read blocks of data from an SDIO card using IO_RW_EXTENDED (CMD53)
	    //
	    // This function performs read operation using CMD53 in block mode.
	    // For byte mode, see sdmmc_io_read_bytes.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param addr  byte address within IO function where writing starts
	    // @param dst  buffer which receives the data read from card
	    // @param size  number of bytes to read, must be divisible by the card block
	    //              size; if size is zero - used dst.size().
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes or greater then dst.size()
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t blocks(uint32_t function, uint32_t addr, std::vector<uint8_t> &dst, size_t size = 0);
	private:
	    IO& iohandler;

	}; /* class SD::MMC::IO::Read */


	// I/O Write operation functions
	class Write
	{
	public:

	    // Constructor
	    Write(IO* io)/*: iohandler(*io) {}*/;

	    //!
	    // Write one byte to an SDIO card using IO_RW_DIRECT (CMD52)
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param reg  byte address within IO function
	    // @param in_byte  value to be written
	    // @param[out] out_byte  if not NULL, receives new byte value read
	    //                       from the card (read-after-write).
	    // @return
	    //      - ESP_OK on success
	    //      - One of the error codes from SDMMC host controller
	    //    esp_err_t sdmmc_io_write_byte(sdmmc_card_t *card, uint32_t function, uint32_t reg, uint8_t in_byte, uint8_t *out_byte);
	    // Simply read the byte
	    esp_err_t byte(uint32_t function, uint32_t reg, uint8_t in_byte);
	    // Read-after-write version of
	    esp_err_t byte(uint32_t function, uint32_t reg, uint8_t in_byte, uint8_t &out_byte);

	    //!
	    // Write multiple bytes to an SDIO card using IO_RW_EXTENDED (CMD53)
	    //
	    // This function performs write operation using CMD53 in byte mode.
	    // For block mode, see sdmmc_io_write_blocks.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param addr  byte address within IO function where writing starts
	    // @param src  data to be written
	    // @param size  number of bytes to write; if size is zero - used dst.size()
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes or greater then dst.size()
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t bytes(uint32_t function, uint32_t addr, const std::vector<uint8_t> &src, size_t size = 0);

	    //!
	    // Write blocks of data to an SDIO card using IO_RW_EXTENDED (CMD53)
	    //
	    // This function performs write operation using CMD53 in block mode.
	    // For byte mode, see sdmmc_io_write_bytes.
	    //
	    // @param card  pointer to card information structure previously initialized
	    //              using sdmmc_card_init
	    // @param function  IO function number
	    // @param addr  byte address within IO function where writing starts
	    // @param src  data to be written
	    // @param size  number of bytes to read, must be divisible by the card block
	    //              size; if size is zero - used dst.size().
	    // @return
	    //      - ESP_OK on success
	    //      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes or greater then dst.size()
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t blocks(uint32_t function, uint32_t addr, const std::vector<uint8_t> &src, size_t size = 0);

	private:
	    IO& iohandler;

	}; /* class SD::IO::Write */

	Read read;
	Write write;
	Interrupt interrupt;
	CIS cis;

    private:

	Card& card;

    }; /* class SD::IO*/


    // Incapsulation the sdmmc_card_t type data &
    // C++ wrapper for the api functions of it.
    class Card
    {
    public:

	Card();

	//!
	// Probe and initialize SD/MMC card using given host
	//
	// @note Only SD cards (SDSC and SDHC/SDXC) are supported now.
	//       Support for MMC/eMMC cards will be added later.
	//
	// @param host  pointer to structure defining host controller
	// @param out_card  pointer to structure which will receive information
	//                  about the card when the function completes
	// @return
	//      - ESP_OK on success
	//      - One of the error codes from SDMMC host controller
	esp_err_t init(const sdmmc_host_t *host) { return sdmmc_card_init(host, self);};
	esp_err_t init(const sdmmc_host_t& host) { return sdmmc_card_init(&host, self);};
	esp_err_t init(const MMC::Host& host) { return sdmmc_card_init(&host.instance, self);};

	/// for a class Device: request formatting SD-card if mount failed:
	enum class format {
		no = 0,	// no format
		yes = 1	// format, if card mounting - fail
	    }; /* struct SD::Card::format */

	//!
	// Print information about the card to a stream.
	//
	// @param  outfile – stream obtained using fopen or fdopen, default - stdopen
	// @return  ESP_OK
	esp_err_t  info(FILE* outfile = stdout);
	//! Print CIS info to outfile - High level procedure
	// @param  outfile – stream obtained using fopen or fdopen, default - stdopen
	// @return  ESP_OK
	esp_err_t print_cis(FILE* outfile = stdout);


	//!
	// Get status of SD/MMC card
	//
	// param "card": used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @return
	//      - ESP_OK on success
	//      - One of the error codes from SDMMC host controller
	esp_err_t status() { return sdmmc_get_status(self); };


	class Sectors
	{
	public:

	    Sectors(Card *media): card(media) {};

	    //!
	    // Write given number of sectors to SD/MMC card
	    //
	    // param "card": used inner pointer to card information structure
	    //               that previously initialized using sdmmc_card_init
	    // @param src   pointer to data buffer to read data from; data size must be
	    //              equal to sector_count * card->csd.sector_size
	    // @param start_sector  sector where to start writing
	    // @param sector_count  number of sectors to write
	    // @return
	    //      - ESP_OK on success
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t write(const std::vector<uint8_t> &src, size_t start_sector, size_t sector_count = 0)
			{ return (sector_count > src.size())? ESP_ERR_INVALID_SIZE:
				sdmmc_write_sectors(card->self, src.data(), start_sector, (!sector_count)? src.size(): sector_count); };

	    //!*
	    // Read given number of sectors from the SD/MMC card
	    //
	    // param "card": used inner pointer to card information structure
	    //               that previously initialized using sdmmc_card_init
	    // @param dst   pointer to data buffer to write into; buffer size must be
	    //              at least sector_count * card->csd.sector_size
	    // @param start_sector  sector where to start reading
	    // @param sector_count  number of sectors to read
	    // @return
	    //      - ESP_OK on success
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t read(std::vector<uint8_t> &dst, size_t start_sector, size_t sector_count = 0)
			{ return (sector_count > dst.size())? ESP_ERR_INVALID_SIZE:
				sdmmc_read_sectors(card->self, dst.data(), start_sector, (!sector_count)? dst.size(): sector_count);};


#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5,0,0)

	    //!
	    // Erase given number of sectors from the SD/MMC card
	    //
	    // @note When sdmmc_erase_sectors used with cards in SDSPI mode, it was
	    // observed that card requires re-init after erase operation.
	    //
	    // param "card": used inner pointer to card information structure
	    //               that previously initialized using sdmmc_card_init
	    // @param start_sector  sector where to start erase
	    // @param sector_count  number of sectors to erase
	    // @param arg  erase command (CMD38) argument
	    // @return
	    //      - ESP_OK on success
	    //      - One of the error codes from SDMMC host controller
	    esp_err_t erase(size_t start_sector, size_t sector_count, sdmmc_erase_arg_t arg)
			{ return sdmmc_erase_sectors(card->self, start_sector, sector_count, arg);};
#endif	// ESP_IDF_VERSION_VAL(x,y,p)

	private:
	    Card *card;
	}; /* SD::Card::Sectors */



#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5,0,0)

	//!
	// Check if SD/MMC card supports discard
	//
	// param "card": is used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @return
	//      - ESP_OK if supported by the card/device
	//      - ESP_FAIL if not supported by the card/device
	esp_err_t discardable() { return sdmmc_can_discard(self);};

	//!
	// Check if SD/MMC card supports trim
	//
	// param "card": used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @return
	//      - ESP_OK if supported by the card/device
	//      - ESP_FAIL if not supported by the card/device
	esp_err_t trimmable() { return sdmmc_can_trim(self);};

	//!
	// Check if SD/MMC card supports sanitize
	//
	// param "card": used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @return
	//      - ESP_OK if supported by the card/device
	//      - ESP_FAIL if not supported by the card/device
	esp_err_t sanitizable() {return sdmmc_mmc_can_sanitize(self);};

	//!
	// Sanitize the data that was unmapped by a Discard command
	//
	// @note  Discard command has to precede sanitize operation. To discard, use
	//        MMC_DICARD_ARG with sdmmc_erase_sectors argument
	//
	// param "card": used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @param timeout_ms timeout value in milliseconds required to sanitize the
	//                   selected range of sectors.
	// @return
	//      - ESP_OK on success
	//      - One of the error codes from SDMMC host controller
	esp_err_t sanitize(uint32_t timeout_ms) { return sdmmc_mmc_sanitize(self, timeout_ms); };

	//!
	// Erase complete SD/MMC card
	//
	// param "card": used inner pointer to card information structure
	//               that previously initialized using sdmmc_card_init
	// @return
	//      - ESP_OK on success
	//      - One of the error codes from SDMMC host controller
	esp_err_t full_erase() { return sdmmc_full_erase(self);};
#endif	// ESP_IDF_VERSION_VAL(x,y,p)

	Sectors sectors;
	/*MMC::*/IO io;

    private:
	esp_err_t ret;

    public:
	static const char* TAG;
	sdmmc_card_t* self;

    }; /* class SD::Card */


    namespace MMC
    {
	// Implementation of the mounting actions:
	// - Options for mounting the filesystem.
	//     (If format_if_mount_failed is set
	//	to true, SD card will be partitioned
	//	and formatted in case when mounting
	//	fails.)
	// - Implementation the mount & unmount methods.
	struct Device
	{
#if 0
	    Slot(bus::width width, pullup pullup_st = pullup::no, wp::active level = wp::active::low, uhs mode = uhs::no);
	    Slot(MMC::pullup pullup_st = pullup::no, wp::active level = wp::active::low, uhs mode = uhs::no);
#endif

	    Device(const Slot& exslot, slot::no no, uint32_t flags = 0, int maxfreq = SDMMC_FREQ_DEFAULT, /*pullup pullup_st = pullup::no,
		    wp::active level = wp::active::low, uhs mode = uhs::no,
//		    bus::width = bus::width::def, pullup = pullup::no,*/
		    /*esp_vfs_fat_sdmmc_mount_config_t&&*/ const FAT::mount::config&/*&*/ mnt_cfg = FAT::mount::def/*(esp_vfs_fat_sdmmc_mount_config_t)(VFS_FAT_MOUNT_DEFAULT_CONFIG())*/
		    			    /*{ .format_if_mount_failed = false,
						.max_files = 5,
						.allocation_unit_size = 16*1024,
						.disk_status_check_enable = false,
						.use_one_fat = false
						}*/ ):
		host(no, slot, flags, maxfreq),
		slot(exslot),
		mnt(mnt_cfg)
	    {			/*selective_log_level_set("Device::valid_path", ESP_LOG_DEBUG);*/	/* for debug purposes */
			// mnt.format_if_mount_failed = mnt_cfg.format_if_mount_failed;
			// mnt.max_files = mnt_cfg.max_files;
			// mnt.allocation_unit_size = mnt_cfg.allocation_unit_size;
	    };
#if 0	// Example
			MMC::Device::Device(bus::width width, Host::pullup pullst, esp_vfs_fat_sdmmc_mount_config_t&& mnt_cfg):
			_host(width, pullst)
			{
			/*selective_log_level_set("Device::valid_path", ESP_LOG_DEBUG);*/	/* for debug purposes */
			mnt.format_if_mount_failed = mnt_cfg.format_if_mount_failed;
			mnt.max_files = mnt_cfg.max_files;
			mnt.allocation_unit_size = mnt_cfg.allocation_unit_size;
			}; /* SD::MMC::Device::Device(bus::width, Host::Pullup, esp_vfs_fat_sdmmc_mount_config_t&) */
#endif
	    Device(const Slot& exslot, slot::no no, uint32_t flags = 0, int maxfreq = SDMMC_FREQ_DEFAULT,
		    SD::Card::format autofmt = Card::format::no,
		    int mxfiles = 5, size_t unitsz = 16 * 1024, bool diskst_chk = false, bool one_fat = false,
//		    bus::width = bus::width::def, pullup = pullup::no);
		    bus::width width = bus::width::def//, pullup pullup_st = pullup::no,
//		    wp::active level = wp::active::low, uhs mode = uhs::no);
		    ):
		    host(no, slot, flags, maxfreq),
		    slot(exslot),
		//    mnt{(autofmt == Card::format::yes), max_files, unit_size, disk_st_chk, one_fat}
		    mnt{esp_vfs_fat_sdmmc_mount_config_t({
			.format_if_mount_failed = (autofmt == Card::format::yes),
			.max_files = mxfiles,
			.allocation_unit_size = unitsz,
			.disk_status_check_enable = diskst_chk,
			.use_one_fat = one_fat })}
	    {};

#if 0	// Example
MMC::Device::Device(Card::format autofmt, int max_files, size_t size, bool disk_st_chk,
    bus::width width, Host::pullup pull):
_host(width, pull)
{
/*selective_log_level_set("Device::valid_path", ESP_LOG_DEBUG);*/	/* for debug purposes */
mnt.format_if_mount_failed = (autofmt == Card::format::yes)? true: false;
mnt.max_files = max_files;
mnt.allocation_unit_size = size;
mnt.disk_status_check_enable = disk_st_chk;
}; /* SD::MMC::Device::Device(Card::format::mntfail, int, size_t, bus::width, Host::Pullup) */
#endif	// Example

//	    Host& host() {return _host;};

	    Host  host;
	    Slot slot;


	    esp_err_t mount(Card&, std::string mountpoint);	// Mount default SD-card slot onto path "mountpoint"
//	    esp_err_t mount(Card&, int slot_no);		// Mount SD-card slot "slot_no" onto default mount path
//	    esp_err_t mount(Card&, int slot_no, const std::string&);  // Mount SD-card slot "slot_no" onto default mount path

	    esp_err_t unmount();	// Unmount SD-card, that mounted onto own mountpath
	    //esp_err_t unmount(const std::string& = "");	// Unmount SD-card, that mounted onto "mountpath", default - call w/o mountpath
	    //esp_err_t unmount(sdmmc_card_t *card);	// Unmount SD-card "card", mounted onto default mountpath
	    //esp_err_t unmount(const std::string& base_path, sdmmc_card_t *card);	// Unmount mounted SD-card "card", mounted onto mountpath
	    bool mounted() {return card != nullptr;};	// is devise mounted?


	    /// get mountpath
	    const std::string& mountpath() const {return target;};
	    /// get mountpath, C string version
	    const char *mountpath_c() const {return target.c_str();};
	    /// set mountpath, return old mountpath
	    std::string mountpath(std::string newpath) { if (!mounted()) std::swap(newpath, target); return newpath; };
	    std::string clean_mountpath() {return mountpath("");};

	    //! get current slot number
	    // @return   current slot number
	    int slot_no() {return host.slot_no();}

	    //! set slot number of the host
	    //
	    // @note  use сarefully! may be incorrect behavior!
	    // @param num  new slot number
	    // @return    prev slot number
	    int slot_no(int num) {/*return*/ host.slot_no((num == 0)? slot::number_0: ((num == 1)? slot::number_1: slot::out_of_range)); return host.slot_no();}

	    Card* card = nullptr;

	private:

	    std::string target = "";
	    /*esp_vfs_fat_sdmmc_mount_config_t*/ FAT::mount::config mnt;
	    esp_err_t ret = ESP_OK;	// Error status

	}; /* struct SD::MMC::Device */

    }; //--[ namespace SD::MMC ]---------------------------------------------------------------------------------------


    //--[ class SD::Host ]---------------------------------------------------------------------------------------------

    //
    // @brief Unmount an SD card from the FAT filesystem and release resources acquired
    inline
    esp_err_t SD::Host::unmount(std::string_view path, Card& card)
    {
	return (err = esp_vfs_fat_sdcard_unmount(path.data(), card.self));
    }; /* SD::Host::unmount() */

#if 0
//TODO 4Remove
    //--[ class SD::MMC::Host ]----------------------------------------------------------------------------------------

    //
    // @brief Convenience function to get FAT filesystem on SD card registered in VFS
    //
    esp_err_t esp_vfs_fat_sdmmc_mount(const char *base_path, const sdmmc_host_t *host_config,
					const void *slot_config, const esp_vfs_fat_mount_config_t *mount_config,
					sdmmc_card_t **out_card);

    //
    // @brief Convenience function to get FAT filesystem on SD card registered in VFS
    //
    inline esp_err_t MMC::Host::mount(std::string_view path, esp_vfs_fat_mount_config_t& mount_config, Card& card) {
	return (err = esp_vfs_fat_sdmmc_mount(path.data(), &instance/*&cfg*//*host_cfg*/, &_slot/*slot cfg*/, &mount_config, &card.self));
    };
#endif


    //--[ class SD::Card ]---------------------------------------------------------------------------------------------

    inline Card::Card():
	sectors(this),
	io(this),
	ret(ESP_OK),
	self(nullptr)
    {};

    //--[ class SD::MMC::IO inlines ]----------------------------------------------------------------------------------

    // Constructor
    inline IO::IO(Card* holder):
	read(this),
	write(this),
	interrupt(this),
	cis(this),
	card(*holder)
    {};

    //!
    // Enable SDIO interrupt in the SDMMC host
    // Inline mplementatipon
    // Handling card object must be previously initialized
    // by using sdmmc_card_init
    esp_err_t inline
    IO::Interrupt::enable() {
	return sdmmc_io_enable_int(iohandler.card.self);};

    //!
    // Block until an SDIO interrupt is received
    // Inline mplementatipon
    //
    // Slave uses D1 line to signal interrupt condition to the host.
    // This function can be used to wait for the interrupt.
    // Handling card object must be previously initialized
    // by using sdmmc_card_init
    esp_err_t inline
    IO::Interrupt::wait(TickType_t timeout_ticks) {
	return sdmmc_io_wait_int(iohandler.card.self, timeout_ticks);};

    //!
    // Get the data of CIS region of an SDIO card.
    // Inline implementation
    //
    // You may provide a buffer not sufficient to store all the CIS data. In this
    // case, this function stores as much data into your buffer as possible. Also,
    // this function will try to get and return the size required for you.
    // Handling card object must be previously initialized
    // by using sdmmc_card_init
    esp_err_t inline
    IO::CIS::data(std::vector<uint8_t> &outbuf, size_t &inout_cis_size) {
	return sdmmc_io_get_cis_data(iohandler.card.self, outbuf.data(), outbuf.size(), &inout_cis_size);};

    //!
    // Parse and print the CIS information of an SDIO card.
    //
    // @note Not all the CIS codes and all kinds of tuples are supported. If you
    // see some unresolved code, you can add the parsing of these code in
    // sdmmc_io.c and contribute to the IDF through the Github repository.
    esp_err_t inline
    IO::CIS::info(std::vector<uint8_t> buff, FILE *fp) {
	return sdmmc_io_print_cis_info(buff.data(), buff.size(), fp);};


    //--[ class IO::Read inlines ]-----------------------------------------------------------------------------------------

    /// Constructor
    inline IO::Read::Read(IO* io):
	iohandler(*io)
    {};

    //!
    // Read one byte from an SDIO card using IO_RW_DIRECT (CMD52)
    // Inline implementation
    esp_err_t inline
    IO::Read::byte(uint32_t function, uint32_t reg, uint8_t &out_byte) {
	return sdmmc_io_read_byte(iohandler.card.self, function, reg, &out_byte);};

    //!
    // Read multiple bytes from an SDIO card using IO_RW_EXTENDED (CMD53)
    // Inline implementation
    //
    // This function performs read operation using CMD53 in byte mode.
    // For block mode, see sdmmc_io_read_blocks.
    esp_err_t inline
    IO::Read::bytes(uint32_t function, uint32_t addr, std::vector<uint8_t> &dst, size_t size) {
	return (size > dst.size()) ? ESP_ERR_INVALID_SIZE:
		sdmmc_io_read_bytes(iohandler.card.self, function, addr, dst.data(), (size == 0)? dst.size(): size);};

    //!
    // Read blocks of data from an SDIO card using IO_RW_EXTENDED (CMD53)
    // Inline implementation
    //
    // This function performs read operation using CMD53 in block mode.
    // For byte mode, see sdmmc_io_read_bytes.
    esp_err_t inline
    IO::Read::blocks(uint32_t function, uint32_t addr, std::vector<uint8_t> &dst, size_t size) {
	return (size > dst.size())? ESP_ERR_INVALID_SIZE:
		sdmmc_io_read_blocks(iohandler.card.self, function, addr, dst.data(), (size == 0)? dst.size(): size);};


    //--[ class IO::Write inlines ]------------------------------------------------------------------------------------

    /// Constructor
    inline IO::Write::Write(IO* io):
	iohandler(*io)
    {};

    //!
    // Write one byte to an SDIO card using IO_RW_DIRECT (CMD52)
    // Inline implementation
    esp_err_t inline
    IO::Write::byte(uint32_t function, uint32_t reg, uint8_t in_byte) {
	return sdmmc_io_write_byte(iohandler.card.self, function, reg, in_byte, nullptr);};
    esp_err_t inline
    IO::Write::byte(uint32_t function, uint32_t reg, uint8_t in_byte, uint8_t &out_byte) {
	return sdmmc_io_write_byte(iohandler.card.self, function, reg, in_byte, &out_byte);};

    //!
    // Write multiple bytes to an SDIO card using IO_RW_EXTENDED (CMD53)
    // Inline implementation
    //
    // This function performs write operation using CMD53 in byte mode.
    // For block mode, see sdmmc_io_write_blocks.
    esp_err_t inline
    IO::Write::bytes(uint32_t function, uint32_t addr, const std::vector<uint8_t> &src, size_t size)	{
	return (size > src.size())? ESP_ERR_INVALID_SIZE:
		sdmmc_io_write_bytes(iohandler.card.self, function, addr, src.data(), (size == 0)? src.size(): size);};

    //!
    // Write blocks of data to an SDIO card using IO_RW_EXTENDED (CMD53)
    //
    // This function performs write operation using CMD53 in block mode.
    // For byte mode, see sdmmc_io_write_bytes.
    esp_err_t inline
    IO::Write::blocks(uint32_t function, uint32_t addr, const std::vector<uint8_t> &src, size_t size) {
	return (size > src.size())? ESP_ERR_INVALID_SIZE:
		sdmmc_io_write_blocks(iohandler.card.self, function, addr, src.data(), (size == 0)? src.size(): size);};

}; //--[ namespace SD ]------------------------------------------------------------------------------------------------


//--[ EoF sdcard_io ]--------------------------------------------------------------------------------------------------
